/**
 * Data Ingestion API
 * POST /api/ingest - Accepts GPS data points, segments trips, detects drops
 */

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { prisma } from '@/lib/prisma';
import { detectDrops, extractCorridors, GPSFix } from '@/lib/gps-processing';
import { computeBaselines } from '@/lib/baseline-computation';
import { checkAndCreateAlerts } from '@/lib/alert-service';

const GPS_POINT_SCHEMA = z.object({
  vehicleId: z.string(),
  tripId: z.string().optional(),
  ts: z.string().datetime(),
  lat: z.number().min(-90).max(90),
  lon: z.number().min(-180).max(180),
  speed: z.number().optional(),
  accuracy: z.number().optional(),
  heading: z.number().optional(),
});

const BATCH_SCHEMA = z.array(GPS_POINT_SCHEMA);

const TRIP_GAP_MINUTES = 20;
const MAX_POINTS_PER_REQUEST = 2000; // Increased batch limit for faster processing

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    // Support both single point and batch ingestion
    const points = Array.isArray(body) ? body : [body];
    
    // SAFETY: Limit batch size to prevent overload
    if (points.length > MAX_POINTS_PER_REQUEST) {
      console.log(`[INGEST] ⚠️ Batch too large: ${points.length} points, limiting to ${MAX_POINTS_PER_REQUEST}`);
      return NextResponse.json({
        error: `Batch too large. Maximum ${MAX_POINTS_PER_REQUEST} points per request.`,
        received: points.length,
      }, { status: 400 });
    }
    
    try {
      var validatedPoints = BATCH_SCHEMA.parse(points);
    } catch (validationError) {
      console.error('[INGEST] Validation error:', validationError);
      console.error('[INGEST] Sample point:', JSON.stringify(points[0]));
      throw validationError;
    }
    
    console.log(`[INGEST] Received ${validatedPoints.length} GPS points`);
    
    if (validatedPoints.length === 0) {
      return NextResponse.json({ error: 'No points provided' }, { status: 400 });
    }
    
    // Group by vehicle
    const byVehicle = new Map<string, typeof validatedPoints>();
    for (const point of validatedPoints) {
      if (!byVehicle.has(point.vehicleId)) {
        byVehicle.set(point.vehicleId, []);
      }
      byVehicle.get(point.vehicleId)!.push(point);
    }
    
    const results = [];
    
    for (const [vehicleId, vehiclePoints] of byVehicle.entries()) {
      // Ensure vehicle exists
      let vehicle = await prisma.vehicle.findUnique({ where: { name: vehicleId } });
      if (!vehicle) {
        vehicle = await prisma.vehicle.create({ data: { name: vehicleId } });
      }
      
      // Sort points by timestamp
      const sorted = vehiclePoints.sort(
        (a, b) => new Date(a.ts).getTime() - new Date(b.ts).getTime()
      );
      
      // Segment into trips (gap > TRIP_GAP_MINUTES)
      const trips: typeof validatedPoints[] = [];
      let currentTrip: typeof validatedPoints = [];
      
      for (const point of sorted) {
        if (currentTrip.length === 0) {
          currentTrip.push(point);
          continue;
        }
        
        const lastPoint = currentTrip[currentTrip.length - 1];
        const gapMinutes = 
          (new Date(point.ts).getTime() - new Date(lastPoint.ts).getTime()) / 60000;
        
        if (gapMinutes > TRIP_GAP_MINUTES) {
          trips.push(currentTrip);
          currentTrip = [point];
        } else {
          currentTrip.push(point);
        }
      }
      
      if (currentTrip.length > 0) {
        trips.push(currentTrip);
      }
      
      // Process each trip
      for (const tripPoints of trips) {
        if (tripPoints.length < 2) continue; // Need at least 2 points
        
        const startTime = new Date(tripPoints[0].ts);
        const endTime = new Date(tripPoints[tripPoints.length - 1].ts);
        
        // Find or create trip
        let trip = tripPoints[0].tripId
          ? await prisma.trip.findUnique({ where: { id: tripPoints[0].tripId } })
          : null;
        
        if (!trip) {
          trip = await prisma.trip.create({
            data: {
              vehicleId: vehicle.id,
              startTime,
              endTime,
              source: 'api_ingest',
            },
          });
        } else {
          // Update trip end time
          await prisma.trip.update({
            where: { id: trip.id },
            data: { endTime },
          });
        }
        
        // Insert GPS points (batch)
        try {
          const gpsData = tripPoints.map(p => ({
            tripId: trip.id,
            ts: new Date(p.ts),
            lat: p.lat,
            lon: p.lon,
            speed: p.speed || null,
            accuracy: p.accuracy || null,
            heading: p.heading || null,
          }));
          
          console.log(`[INGEST] Attempting to store ${gpsData.length} GPS points for trip ${trip.id}`);
          console.log(`[INGEST] Sample GPS point:`, JSON.stringify(gpsData[0]));
          
          const result = await prisma.gPSPoint.createMany({
            data: gpsData,
          });
          
          console.log(`[INGEST] ✅ Stored ${result.count} GPS points for trip ${trip.id}`);
        } catch (gpsError) {
          console.error(`[INGEST] ❌ Failed to store GPS points:`, gpsError);
          if (gpsError instanceof Error) {
            console.error(`[INGEST] Error details:`, gpsError.message);
            console.error(`[INGEST] Stack:`, gpsError.stack);
          }
          throw gpsError;
        }
        
        // Detect drops
        const gpsFixes: GPSFix[] = tripPoints.map(p => ({
          ts: new Date(p.ts),
          lat: p.lat,
          lon: p.lon,
          speed: p.speed,
          accuracy: p.accuracy,
          heading: p.heading,
        }));
        
        const tauShort = parseInt(process.env.TAU_SHORT || '60');
        const drops = detectDrops(gpsFixes, tauShort);
        
        console.log(`[INGEST] Trip ${trip.id}: ${tripPoints.length} points -> ${drops.length} drops detected`);
        
        // Store drops
        if (drops.length > 0) {
          await prisma.drop.createMany({
            data: drops.map(d => ({
              tripId: trip.id,
              startTs: d.startTs,
              endTs: d.endTs,
              startLat: d.startLat,
              startLon: d.startLon,
              endLat: d.endLat,
              endLon: d.endLon,
              durationSec: d.durationSec,
              reason: d.reason,
            })),
          });
        }
        
        // Extract corridors from drops (blindspots/signal loss)
        const h3Res = parseInt(process.env.H3_RESOLUTION || '7');
        const dropCorridors = extractCorridors(drops, h3Res);
        
        // Extract corridors from normal consecutive GPS points (regular movement)
        const movementCorridors = extractCorridorsFromPoints(gpsFixes, h3Res);
        
        // Combine both types of corridors
        const allTraversals = [...dropCorridors, ...movementCorridors];
        
        console.log(`[INGEST] Trip ${trip.id}: ${dropCorridors.length} drop corridors + ${movementCorridors.length} movement corridors = ${allTraversals.length} total traversals`);
        
        // Batch process corridors: collect unique corridor keys first
        
        const uniqueKeys = new Map<string, typeof corridorKeys[0]>();
        
        for (const key of corridorKeys) {
          const keyStr = `${key.aH3}_${key.bH3}_${key.direction}`;
          if (!uniqueKeys.has(keyStr)) {
            uniqueKeys.set(keyStr, key);
          }
        }
        
        // Batch find existing corridors
        const existingCorridors = await prisma.corridor.findMany({
          where: {
            OR: Array.from(uniqueKeys.values()).map(key => ({
              aH3: key.aH3,
              bH3: key.bH3,
              direction: key.direction,
            })),
          },
        });
        
        // Map existing corridors by key
        const corridorMap = new Map<string, string>(); // keyStr -> corridorId
        for (const corridor of existingCorridors) {
          const keyStr = `${corridor.aH3}_${corridor.bH3}_${corridor.direction}`;
          corridorMap.set(keyStr, corridor.id);
        }
        
        // Create missing corridors in batch
        const missingKeys = Array.from(uniqueKeys.entries())
          .filter(([keyStr]) => !corridorMap.has(keyStr));
        
        if (missingKeys.length > 0) {
          const newCorridors = await prisma.$transaction(
            missingKeys.map(([_, key]) =>
              prisma.corridor.create({
                data: {
                  aH3: key.aH3,
                  bH3: key.bH3,
                  direction: key.direction,
                },
              })
            )
          );
          
          // Add new corridors to map
          for (let i = 0; i < newCorridors.length; i++) {
            const corridor = newCorridors[i];
            const keyStr = missingKeys[i][0];
            corridorMap.set(keyStr, corridor.id);
          }
        }
        
        // Batch create traversals
        const traversalData = allTraversals.map(traversal => {
          const { corridorKey, ...data } = traversal;
          const keyStr = `${corridorKey.aH3}_${corridorKey.bH3}_${corridorKey.direction}`;
          const corridorId = corridorMap.get(keyStr)!;
          
          return {
            corridorId,
            tripId: trip.id,
            startTs: data.startTs,
            endTs: data.endTs,
            travelSec: data.travelSec,
            avgSpeedKmh: data.avgSpeedKmh,
            startLat: data.startLat,
            startLon: data.startLon,
            endLat: data.endLat,
            endLon: data.endLon,
          };
        });
        
        if (traversalData.length > 0) {
          await prisma.traversal.createMany({
            data: traversalData,
          });
        }
        
        // DISABLED: Update baselines in batch later to prevent infinite loop
        // TODO: Run baseline computation as a separate batch job after ingestion completes
        
        // DISABLED: Check alerts - will implement as batch job
        // TODO: Run alert checking after baseline computation completes
        
        results.push({
          tripId: trip.id,
          vehicleId: vehicle.id,
          pointsProcessed: tripPoints.length,
          dropsDetected: drops.length,
          corridorsTraversed: allTraversals.length,
        });
      }
    }
    
    return NextResponse.json({ ok: true, results });
  } catch (error) {
    console.error('[INGEST] ❌ Ingestion error:', error);
    
    if (error instanceof z.ZodError) {
      console.error('[INGEST] Validation issues:', JSON.stringify(error.issues, null, 2));
      return NextResponse.json(
        { error: 'Validation error', details: error.issues },
        { status: 400 }
      );
    }
    
    // Log full error details
    if (error instanceof Error) {
      console.error('[INGEST] Error message:', error.message);
      console.error('[INGEST] Error stack:', error.stack);
    }
    
    return NextResponse.json(
      { 
        error: 'Internal server error',
        message: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

/**
 * Update corridor baselines after new traversals
 */
async function updateCorridorBaselines(corridorId: string) {
  const traversals = await prisma.traversal.findMany({
    where: { corridorId },
    select: {
      travelSec: true,
      avgSpeedKmh: true,
      startTs: true,
    },
  });
  
  if (traversals.length === 0) return;
  
  const baselines = computeBaselines(corridorId, traversals);
  
  // Upsert baselines
  for (const baseline of baselines) {
    await prisma.corridorStats.upsert({
      where: {
        corridorId_bucketHour: {
          corridorId: baseline.corridorId,
          bucketHour: baseline.bucketHour,
        },
      },
      create: {
        corridorId: baseline.corridorId,
        bucketHour: baseline.bucketHour,
        count: baseline.count,
        medianTravelSec: baseline.medianTravelSec,
        p95SpeedKmh: baseline.p95SpeedKmh,
      },
      update: {
        count: baseline.count,
        medianTravelSec: baseline.medianTravelSec,
        p95SpeedKmh: baseline.p95SpeedKmh,
      },
    });
  }
}



